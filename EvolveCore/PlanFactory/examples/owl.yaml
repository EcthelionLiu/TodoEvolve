python_code: |-
  <<<PYTHON>>>
  import textwrap
  from typing import Any, Callable, Dict, List, Optional

  from jinja2 import StrictUndefined, Template
  from rich.rule import Rule
  from rich.text import Text

  from ..memory import ActionStep, AgentMemory, PlanningStep, SummaryStep
  from ..models import ChatMessage, MessageRole
  from ..monitoring import AgentLogger, LogLevel
  from ..tools import Tool
  from .base_planning import BasePlanning


  def populate_template(template: str, variables: Dict[str, Any]) -> str:
      compiled_template = Template(template, undefined=StrictUndefined)
      try:
          return compiled_template.render(**variables)
      except Exception as e:
          raise Exception(f"Error during jinja template rendering: {type(e).__name__}: {e}")


  class PlannerPlanning(BasePlanning):

      def __init__(
          self,
          model: Callable[[List[Dict[str, str]]], ChatMessage],
          tools: Dict[str, Tool],
          prompt_templates: Dict[str, Any],
          memory: AgentMemory,
          logger: AgentLogger,
      ):
          super().__init__(model, tools, prompt_templates, memory, logger)

      def topology_initialize(self, task: str) -> PlanningStep:
          """
          Generate initial task plan and record to memory and logger.
          """

          # System prompt (planning.initial_plan)
          system_msg = {
              "role": MessageRole.SYSTEM,
              "content": [{
                  "type": "text",
                  "text": populate_template(
                      self.prompt_templates["planning"]["initial_plan"],
                      variables={"tools": self.tools},
                  ),
              }],
          }

          # User prompt (planning.task_input) â€“ keep it minimal and stable
          user_msg = {
              "role": MessageRole.USER,
              "content": [{
                  "type": "text",
                  "text": populate_template(
                      self.prompt_templates["planning"]["task_input"],
                      variables={"task": task},
                  ),
              }],
          }

          input_messages = [system_msg, user_msg]

          chat_message_plan: ChatMessage = self.model(input_messages)
          plan_text = chat_message_plan.content
          plan_reasoning = chat_message_plan.reasoning_content

          # Log
          final_plan_redaction = textwrap.dedent(
              f"""Here is the plan of action that I will follow to solve the task:\n```\n{plan_text}\n```\n"""
          )
          self.logger.log(
              Rule("[bold]Initial plan", style="orange"),
              Text(final_plan_redaction),
              level=LogLevel.INFO,
          )

          planning_step = PlanningStep(
              model_input_messages=input_messages,
              plan=plan_text,
              plan_think="",  # keep empty unless you have explicit non-cot think
              plan_reasoning=plan_reasoning,
          )
          self.memory.steps.append(planning_step)
          return planning_step

      def adaptation(
          self,
          task: str,
          step: int,
          write_memory_to_messages: Callable[[Optional[List[ActionStep]], Optional[bool]], List[Dict[str, str]]],
      ) -> SummaryStep:

          summary_step = SummaryStep(
              model_input_messages="",
              summary="",
              summary_reasoning="",
          )
          return summary_step
  <<<END_PYTHON>>>
yaml_config: |-
  <<<YAML>>>
  system_prompt: |-
    You are an expert assistant who solves tasks through structured tool calls, following a step-by-step process. Each step (action) involves analyzing needs, selecting tools, and executing calls to achieve the task goal.
    Each action you take should include a reasoning process and tool calls. After executing the tools, you will receive "observations" (results of tool calls), which can be used as input for subsequent actions. 

    # Action Structure
    Each action must contain:
    - "think": A detailed reasoning in English, explaining the analysis of user needs, tool selection logic, and execution plan.
    - "tools": a list of tool calls, each with "name" and "arguments"

    # Task Instructions:
    ### 1. Parse the plan:
    Decompose the original task into several subtasks.
    ### 2. Execute one process at a time:
    In each step, you may execute AT MOST one Process / EndProcess / final_answer tool.
    ### 3. Handle failing cases:
    If a process fails, consider calling EndProcess(status="failed") in next step, generate a new plan.
    ### 4. Tool principles:
    You may call Process tool multiple times in a row within the same subtask. You MUST call EndProcess tool before final_answer tool.

    # Examples
    ---
    Task: "Find the release date of X."
    Action:
    {
      "think": "I need to search for the release date. I will use a web process to search and crawl simultaneously.",
      "tools": [
        {
          "name": "Process",
          "arguments": {
            "process_name": "web",
            "tools": [
              {"plan_think":"","name":"web_search","arguments":{"query":"X release date official"}},
              {"plan_think":"","name":"crawl_page","arguments":{"url":"https://official-site.com"}}
            ]
          }
        }
      ]
    }
    Observation: "Process 'web' executed. Check internal memory."
    Action:
    {
      "think": "The process executed successfully. I will now close the process and merge the findings.",
      "tools": [
        {
          "name": "EndProcess",
          "arguments": {"status": "finished",  "process_name": "web"}
        }
      ]
    }
    Observation: "Process Finished. Findings merged into main memory."
    Action:
    {
      "think": "I have the date from the merged memory. I can answer now.",
      "tools": [
        {"name": "final_answer", "arguments": {"answer": "The release date is..."}}
      ]
    }
    ---
    Task: "Find a rare document Y."
    Action:
    {
      "think": "Starting a web process to find document Y.",
      "tools": [
        {
          "name": "Process",
          "arguments": {
            "process_name": "web",
            "tools": [
              {"name": "web_search", "arguments": {"query": "document Y pdf"}}
            ]
          }
        }
      ]
    }
    Observation: "Process 'web' executed."
    Action:
    {
      "think": "The search results in the memory look irrelevant. This path failed.",
      "tools": [
        {
          "name": "EndProcess",
          "arguments": {"status": "failed", "process_name": "web"}
        }
      ]
    }
    Observation: "Process failed. Memory cleaned. Replanning request initiated."
    ---

    # Available Tools
    {%- for tool in tools.values() %}
    - {{ tool.name }}: {{ tool.description }}
        Takes inputs: {{tool.inputs}}
        Returns an output of type: {{tool.output_type}}
    {%- endfor %}

  planning:
    initial_plan: |-
      You are a world-class planning expert specializing in decomposing tasks into a small number of verifiable goals.
      You need to split the given task into subtasks according to the tools available in the group.

      ### Available Tools:
      {%- for tool in tools.values() %}
      - {{ tool.name }}: {{ tool.description }}
          Takes inputs: {{tool.inputs}}
          Returns an output of type: {{tool.output_type}}
      {%- endfor %}
      However, **vector_similarity_retrieve** tool is not available.

      ### Core Requirements
      1) Produce 1-5 subtasks max.
      2) Plan CANNOT include tool names.

      ### Output Format
      "## Subtask 1: [Subtask 1 content]\n## Subtask 2: [Subtask 2 content] ..."

      Refrain from directly attempting to solve the task.
    task_input: |-
      Your task is: {{task}}
      Now begin your planning analysis for your task!

  replanning:
    initial plan: |-
      You are a replanning assistant responsible for generating a NEW plan after an original plan has failed.
      You are given a failed trajectory and original task. Your goal is to avoid repeating the same failed attempts and to propose alternative, verifiable next attempts.

      Original task:
      {{task}}

      Failed process_name:
      {{process_name}}

      Failure trace (chronological):
      {{trace}}

      ### What counts as "failed" here
      The trace may include:
      - Unhelpful search results (irrelevant snippets, wrong entity, outdated pages)
      - Authoritative-looking URLs whose pages did not contain the needed info
      - JS-rendered pages that the current tools could not extract correctly
      - Rate limits / access blocks / 403/404 / paywalls
      - Tool errors (timeouts, parsing errors, extraction failures)

      You MUST use the trace to infer:
      (1) What was attempted (queries/URLs/strategy)
      (2) Why it failed (root cause, not just symptoms)
      (3) What a genuinely different next attempt would look like

      ### Core Principles
      1) Novelty constraint:
         - Do NOT repeat identical queries or URLs that already failed.
         - Do NOT re-run the same query with only trivial keyword changes.
         - If revisiting the same domain, you must change the retrieval strategy.

      2) Verification constraint:
         - Each proposed next attempt MUST include explicit success criteria that can be checked from observations.
         - Specify exactly what evidence to extract (field/value/short quote <= 25 words/table row/metadata).

      3) Process discipline (DO NOT mention tool names):
         - Assume the executor uses a strict process wrapper and must close with an explicit completion or failure.
         - Your job is to propose the next attempts only, not the exact tool calls.

      ### Output Format
      "Original plan has failed, let me generate a new plan.\n## Subtask 1: [Subtask 1 content]\n## Subtask 2: [Subtask 2 content] ..."

  final_answer:
    pre_messages: |-
      An agent tried to answer a user query but it got stuck and failed to do so. You are tasked with providing an answer instead. Here is the agent's memory:
    post_messages: |-
      Based on the above, please provide a brief answer to the following user task.
      You MUST return your thinking process and answer in the following format:
      {
        "think": "Include your thinking and reasoning process on how to get the final answer here",
        "answer": "Include your final answer here"
      }

      Here is your task:
      {{task}}

  step:
    pre_messages: |-
      Based on the plan and execution steps from previous conversations, analyze and call tools to continue solving the original task:

      # Tool List:
      {{tool_functions_json}}
      However, **vector_similarity_retrieve** tool is strictly abandoned.

      # Your original task:
      {{task}}

      # Core Principles
      - Process / EndProcess must be the ONLY tool in its Action.
      - After at most 3 consecutive Process calls without verifiable evidence, EndProcess(status="failed").
      - Web Process can only contain web_search / crawl_page tools; Reasoning Process can only contain reasoning tool. Empty tool call is invalid.
      - You MUST call EndProcess before calling final_answer tool.
      - process_name must be exactly one of "web" / "reasoning".
      - Inside one Process, you can use multiple sub-tool call. Each sub-tool call MUST include:
        - plan_think: a short rationale for why this step is executed now
        - name: tool name
        - arguments: tool arguments

      # Example output 1
      {
        "think": "I need to search for the release date. I will use a web process to search and crawl simultaneously.",
        "tools": [
          {
            "name": "Process",
            "arguments": {
              "process_name": "web",
              "tools": [
                {"plan_think":"","name":"web_search","arguments":{"query":"X release date official"}},
                {"plan_think":"","name":"crawl_page","arguments":{"url":"https://official-site.com"}}
              ]
            }
          }
        ]
      }
      # Example output 2
      {
        "think": "The search results in the memory look irrelevant. This path failed.",
        "tools": [
          {
            "name": "EndProcess",
            "arguments": {"status": "failed", "process_name": "web"}
          }
        ]
      }

      Example output 3
      {
        "think": "I have gathered all necessary information and can now provide the final answer.",
        "tools": [
          {
            "name": "final_answer",
            "arguments": {
              "answer": "Based on the gathered information, the answer is ..."
            }
          }
        ]
      }

      Now continue to solve the task!
  <<<END_YAML>>>
