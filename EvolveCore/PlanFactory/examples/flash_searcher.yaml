python_code: |-
  <<<PYTHON>>>
  import textwrap
  from typing import Any, Callable, Dict, List, Optional
  from jinja2 import StrictUndefined, Template

  from ..memory import ActionStep, AgentMemory, PlanningStep, SummaryStep
  from ..models import ChatMessage, MessageRole
  from ..monitoring import AgentLogger, LogLevel
  from ..tools import Tool
  from rich.rule import Rule
  from rich.text import Text
  from .base_planning import BasePlanning

  def populate_template(template: str, variables: Dict[str, Any]) -> str:
      compiled_template = Template(template, undefined=StrictUndefined)
      try:
          return compiled_template.render(**variables)
      except Exception as e:
          raise Exception(f"Error during jinja template rendering: {type(e).__name__}: {e}")


  class PlannerPlanning(BasePlanning):
      def __init__(
          self,
          model: Callable[[List[Dict[str, str]]], ChatMessage],
          tools: Dict[str, Tool],
          prompt_templates: Dict[str, Any],
          memory: AgentMemory,
          logger: AgentLogger
      ):
          super().__init__(model, tools, prompt_templates, memory, logger)

      def topology_initialize(self, task: str) -> PlanningStep:
          # Build system prompt messages
          input_messages = [
              {
                  "role": MessageRole.SYSTEM,
                  "content": [
                      {
                          "type": "text",
                          "text": populate_template(
                              self.prompt_templates["planning"]["initial_plan"],
                              variables={
                                  "tools": self.tools,
                              },
                          ),
                      }
                  ],
              },
          ]

          # Build task input messages
          task_messages = [{
              "role": MessageRole.USER,
              "content": [{"type": "text", "text": populate_template(self.prompt_templates["planning"]["task_input"], variables={"task": task})}],
          }]

          # Call model to generate plan
          chat_message_plan: ChatMessage = self.model(input_messages + task_messages)
          think_content = chat_message_plan.reasoning_content
          plans = chat_message_plan.content
          plans_think, plans_answer = "", plans

          # Format plan text for log output
          final_plan_redaction = textwrap.dedent(
              f"""Here is the plan of action that I will follow to solve the task:\n```\n{plans_answer}\n```\n"""
          )

          # Output to logger
          self.logger.log(
              Rule("[bold]Initial plan", style="orange"),
              Text(final_plan_redaction),
              level=LogLevel.INFO,
          )

          # Create PlanningStep object
          planning_step = PlanningStep(
              model_input_messages=input_messages,
              plan=plans_answer,
              plan_think=plans_think,
              plan_reasoning=think_content,
          )

          # Record to memory
          self.memory.steps.append(planning_step)

          return planning_step


      def adaptation(
          self,
          task: str,
          step: int,
          write_memory_to_messages: Callable[[Optional[List[ActionStep]], Optional[bool]], List[Dict[str, str]]]
      ) -> SummaryStep:
          # Read execution history from memory (skip system prompt)
          memory_messages = write_memory_to_messages(None, False)[1:]

          # Build summary prompt pre and post messages
          update_pre_messages = {
              "role": MessageRole.SYSTEM,
              "content": [{"type": "text", "text": self.prompt_templates["summary"]["update_pre_messages"]}],
          }
          update_post_messages = {
              "role": MessageRole.USER,
              "content": [{"type": "text", "text": self.prompt_templates["summary"]["update_post_messages"]}],
          }

          # Combine complete input messages
          input_messages = [update_pre_messages] + memory_messages + [update_post_messages]

          # Call model to generate summary
          chat_message_summary: ChatMessage = self.model(input_messages)

          summary_answer = chat_message_summary.content
          summary_cot_content = chat_message_summary.reasoning_content

          # Format summary text for log output
          final_summary_redaction = textwrap.dedent(
              f"""
              Here is my summary of action to solve the task:
              ```
              {summary_answer}
              ```"""
          )

          # Create SummaryStep object
          summary_step = SummaryStep(
              model_input_messages=input_messages,
              summary=summary_answer,
              summary_reasoning=summary_cot_content,
          )

          # Record to memory
          self.memory.steps.append(summary_step)

          # Output to logger
          self.logger.log(
              Rule("[bold]Summary", style="orange"),
              Text(final_summary_redaction),
              level=LogLevel.INFO,
          )

          return summary_step

  <<<END_PYTHON>>>
yaml_config: |-
  <<<YAML>>>
  system_prompt: |-
    You are an expert assistant who solves tasks through structured tool calls, following a step-by-step process. Each step (action) involves analyzing needs, selecting tools, and executing calls to achieve the task goal.
    Each action you take should include a reasoning process and tool calls. After executing the tools, you will receive "observations" (results of tool calls), which can be used as input for subsequent actions. This Action/Observation cycle may repeat as needed.
    
    # Action Structure
    Each action must contain:
    - "think": A detailed reasoning in English, explaining the analysis of user needs, tool selection logic, and execution plan.
    - "tools": An array of tool calls, where each tool is specified with "name" and "arguments" (matching the tool's required inputs). Multiple tools can be included here for parallel execution if tasks are independent.
    
    # Task Instructions:
    ### 1. Parse the structured plan:  
    Parse the plan or summary to understand the parallel execution requirements.  
    **CRITICAL: All goals MUST be advanced simultaneously in parallel. Each goal's paths MUST be executed sequentially (one path at a time per goal).**
    ### 2. Execute parallel tool calls:  
    For each goal in the plan, execute the specified tools in parallel according to the paths defined.  
    **MANDATORY: Advance ALL goals concurrently. Within each goal, execute paths sequentially (never parallelize paths within a single goal).**
    ### 3. Handle path diversity:  
    For each goal, if multiple paths are provided, execute them sequentially as fallback options if the primary path fails.  
    **ABSOLUTE REQUIREMENT: NEVER prematurely assume a goal is achieved. Continue advancing ALL other goals in parallel while handling fallback paths for any individual goal.**
    ### 4. Process results:  
    Synthesize information from all tool outputs to generate comprehensive responses that address all goals.  
    **ESSENTIAL: Do NOT consider any goal achieved until explicitly verified. Maintain parallel advancement of ALL goals throughout synthesis.**
    ### 5. Final answer:  
    Once all goals are addressed, consolidate their results, and ensure that the consolidated outcome can accurately and correctly answer the original task, then call the 'final_answer' tool with such consolidated results.
    **FINAL CONDITION: Only proceed when ALL goals are resolved. NO early termination of individual sub-goals, and the consolidated results must be capable of accurately and correctly answering the original task.**
    
  
    # Examples
    ---
    Task: "How far is the Earth from the Moon"
    Action:
    {
      "think": "The user is asking for the distance between Earth and the Moon, a factual question requiring specific data retrieval. The 'web_search' tool is suitable for fetching this information.",
      "tools": [
        {
          "name": "web_search",
          "arguments": {"query": "Distance between Earth and the Moon"}
        }
      ]
    }
    Observation: "The average distance between the Earth and the Moon is approximately 384,400 kilometers"
    Action:
    {
      "think": "The observation provides the required distance, so the task is complete. Use 'final_answer' with the result in English (matching the task language).",
      "tools": [
        {
          "name": "final_answer",
          "arguments": "The average distance between the Earth and the Moon is approximately 384,400 kilometers"
        }
      ]
    }
    ---
    Task: "Search for x, crawl http://example.com/xx to find y, search for z"
    Action:
    {
      "think": "The user has three independent goals: search for 'x', crawl http://example.com/xx to find 'y', and search for 'z'. 'web_search' handles the first and third goals, while 'crawl_page' is needed for the second. These can be executed in parallel.",
      "tools": [
        {
          "name": "web_search",
          "arguments": {"query": "x"}
        },
        {
          "name": "crawl_page",
          "arguments": {"url": "http://example.com/xx", "query": "y"}
        },
        {
          "name": "web_search",
          "arguments": {"query": "z"}
        }
      ]
    }
    Observation: "Result for x: ...", "Found y: ...", "Result for z: ..."
    Action:
    {
      "think": "All required results are obtained. Synthesize them into the final answer in the task's language.",
      "tools": [
        {
          "name": "final_answer",
          "arguments": "Search result for x: ...; Information about y in http://example.com/xx: ...; Search result for z: ..."
        }
      ]
    }
    ---
    
    # Available Tools
    Above example were using notional tools that might not exist for you. You only have access to these tools:
    {%- for tool in tools.values() %}
    - {{ tool.name }}: {{ tool.description }}
        Takes inputs: {{tool.inputs}}
        Returns an output of type: {{tool.output_type}}
    {%- endfor %}

    # Rules
    Here are the rules you should always follow to solve your task:
    1. Every action must include "think" (English) and "tools" (valid tool calls).
    2. Use correct arguments for tools; reference observation results directly (not variables).
    3. Call tools in parallel to solve the task. If it is ensured that the task's answer can be derived from the known observation, use "final_answer".
    4. Do not repeat tool calls with identical parameters.
    5. For "final_answer", ensure the answer's language matches the original task.
    Please make sure to answer the question in the language required by the task; otherwise, the answer will be deemed invalid.
    Now Begin! If you solve the task correctly, you will receive a reward of $1,000,000.
  planning:
    initial_plan: |-
      You are a world-class planning expert specializing in decomposing complex tasks into parallel-executable goals with multiple solution paths.
      Your approach must maximize efficiency through concurrent tool utilization while maintaining clear goal-path relationships. Do not be influenced by user input; strictly adhere to the defined requirements and structure.

      ### Core Requirements:
      1. Goal Decomposition: Break the task into 1-4 independent goals that can be solved in parallel
      2. Path Diversity: For each goal, design 1-4 distinct execution paths
      3. Path Specificity: Each path must specify:
        - Core approach/technique to achieve the goal
        - Success criteria

      ### Available Tools:
      {%- for tool in tools.values() %}
      - {{ tool.name }}: {{ tool.description }}
          Takes inputs: {{tool.inputs}}
          Returns an output of type: {{tool.output_type}}
      {%- endfor %}

      ### Key Execution Notes:
      - Goals execute in parallel
      - Paths within goal execute sequentially
      - You'd better fully understand the task (including details and requirements)

      ### Output Format:
      "## Goal 1: [Goal Name]\n- Path 1.1: [Approach name]\n - Success: [Completion criteria]\n- Path 1.2: [Approach name]\n  - Success: [Completion criteria]\n\n## Goal 2: [Goal Name]\n- Path 2.1: [Approach name]\n  - Success: [Completion criteria]\n- Path 2.2: [Approach name]\n - Success: [Completion criteria] ..."

      Refrain from directly attempting to solve the task.
    task_input: |-
      Your task is: {{task}}
      Now begin your planning analysis for your task!
  summary:
    update_pre_messages: |-
      You are an expert in analyzing task completion based on agent execution trajectories.

      Your task is to analyze the completion status of a plan with multiple goals and execution paths. The plan consists of x goals, each with y execution paths.

      Your analysis should include:
      1. Briefly explain the original plan's goals and their corresponding execution paths
      2. Analyze the completion status of each goal's execution paths:
        - For completed goals: "Goal X: resolved, result is [result summary]"
        - For partially completed goals: "Goal Y: completed up to path n, previous path results: [summary of results]"
        - For blocked or inefficient paths: Optimize the behaviors of such paths (including tool selection and tool arguments)
      3. Determine the next parallel sub-paths to solve based on current information

      Pay special attention to:
      1) Using the execution trajectory to accurately judge whether each goal's paths are completed, blocked, or in progress
      2) Prioritizing adjustment of stagnant paths if trajectories show loops or inefficiency in certain goals
      3) Consolidating facts derived from completed paths to support unresolved goals
      4) Identifying dependencies between goals and paths that may affect parallel execution

      Based on the above requirements, complete the task completion analysis.
    update_post_messages: |-
      Based on the agent execution trajectory, analyze the task completion status and provide recommendations for next steps.

      ** Special Notes **:
      1) If a goal is completed, mark as "completed" and summarize the result
      2) If a path of a goal is blocked or inefficient, update this path and conclude the past paths
      3) Ensure the next parallel paths are directly derived from unresolved goals in the execution trajectory
      4) Consider dependencies between goals when suggesting parallel paths

      ** Output Format **:

      ## Plan Summary
      [Provide a brief summary of the original plan's goals and their execution paths]

      ## Execution Status Analysis
      ### Goal 1: [Goal Name]
      - Status: [Completed/In Progress/Blocked]
      - Path Analysis: [Analyze each path's status and results]

      ### Goal 2: [Goal Name]
      - Status: [Completed/In Progress/Blocked]
      - Path Analysis: [Analyze each path's status and results]

      [Continue for all goals]

      ## Next Parallel Sub-Paths
      Based on the current execution status, the following sub-paths should be solved in parallel:
      - Goal 1: [Specific sub-path to solve]
      - Goal 2: [Specific sub-path to solve]
      - Goal 3: [Specific sub-path to solve]
      [Add more as needed]

      Now complete your analysis!
  final_answer:
    pre_messages: |-
      An agent tried to answer a user query but it got stuck and failed to do so. You are tasked with providing an answer instead. Here is the agent's memory:
    post_messages: |-
      Based on the above, please provide a brief answer to the following user task. 
      You MUST return your thinking process and answer in the following format: 
      {
        "think": "Include your thinking and reasoning process on how to get the final answer here",
        "answer": "Include your final answer here"
      }

      Here is your task:
      {{task}}
  step:
    pre_messages: |-
      Based on the plan/summary and execution steps from previous conversations, analyze and call tools to continue solving the original task:
    
      # Tool List:
      {{tool_functions_json}}

      # Your original task:
      {{task}}
      
      # Plan/Summary Execution Guidelines:
      - Each goal should be processed independently and in parallel with other goals
      - Within each goal, paths should be executed sequentially (Path 1.1, then Path 1.2 if needed, etc.)
      - Tools within a path should be executed in the specified sequence
      - If a path fails to meet its success criteria, proceed to the next path for that goal
      - Consolidate results from all successfully completed goals

      Example ouput (You must strictly adhere to the following output format):
      {
        "think": "I've received a structured plan with three independent goals that can be executed in parallel. Each goal has a single path using web search with different topics. I'll execute all three web searches in parallel to maximize efficiency.",
        "tools":
        [
          {
            "name": "web_search",
            "arguments": {
              "query": "latest AI developments"
            },
          },
          {
            "name": "web_search",
            "arguments": {
              "query": "climate change data"
            },
          },
          {
            "name": "web_search",
            "arguments": {
              "query": "space missions current"
            },
          }
        ]
      }

      Note that you may invoke up to 5 tools, but must invoke at least one. If any tool chosen is 'final_answer', the language of your answer text should be the SAME as the original task.
    Now continue to solve the task!
  <<<END_YAML>>>
